from acados_template import AcadosOcp, AcadosOcpSolver
from drone_model import export_quadrotor_ode_model
from drone_model_rpy import convert_to_rpy_model
from common import *
from planner import *
from scipy.linalg import solve_continuous_are
import numpy as np
import casadi as ca


#################  AGGIUSTARE: ricavare snap, jerk, acc in qualche modo perché da y_expr non si può tramite get(...)
##############  Estendere lo stato con tutti gli stati


##############  Assegnare all'oggetto la traiettoria desiderata e mettere nei vincoli lo stare ad una certa distanza
##############  Includere vincoli visuali

def setup_model():
    model = export_quadrotor_ode_model()
    model_rpy = convert_to_rpy_model(model)
    return model, model_rpy

def setup_initial_conditions() :
    xx=0
    y=0
    z=0
    
    vx=0
    vy=0
    vz=0

    roll=0
    pitch=0
    yaw=0
    q = RPY_to_quat(roll,pitch,yaw)

    wx=0
    wy=0
    wz=0

    x0 = np.array([xx,y,z,vx,vy,vz,*q,wx,wy,wz])
    x0_rpy=np.array([xx,y,z,vx,vy,vz,roll,pitch,yaw,wx,wy,wz])
    return x0,x0_rpy


def configure_ocp(model, x0, p_refs, rpy_refs, Tf, ts, W, W_e, radius=2.0):  # aggiunto radius
    #model dimension
    # model.x = [p(3), v(3), quat(4), omega(3)]
    # u = [f(3), tau(3)]
    nx = model.x.rows()
    nu = model.u.rows()

    #prediction horizon time
    N_horiz = int(Tf/ts)

    #Optimization Control Problem creation
    ocp = AcadosOcp()

    #model definition: it's handled as set of equality constraints
    ocp.model = model
    
    #time: total simulation time and prediction horizon
    ocp.solver_options.tf = Tf
    ocp.solver_options.N_horizon = N_horiz

    ##########                          CONSTRAINTS             ################

    #initial conditions for constraints
    ocp.constraints.x0 = x0
    # State constraints
    ocp.constraints.lbx = np.array([0] + [-2]*3 + [-np.deg2rad(60)]*3)
    ocp.constraints.ubx = np.array([12] + [2]*3 + [np.deg2rad(60)]*3)
    ocp.constraints.idxbx = np.array([2, 3, 4, 5, 10, 11, 12])
    # Control constraints
    Fmax = 20  #more or less double tha hovering
    Tmax = 1
    ocp.constraints.lbu = np.array([-Fmax, -Fmax, -Fmax, -Tmax, -Tmax, -Tmax])
    ocp.constraints.ubu = np.array([Fmax, Fmax, Fmax, Tmax, Tmax, Tmax])
    ocp.constraints.idxbu = np.arange(nu)
    # Solver options
    ocp.solver_options.integrator_type = 'ERK'
    ocp.solver_options.qp_solver = 'PARTIAL_CONDENSING_HPIPM'
    ocp.solver_options.nlp_solver_type = 'SQP'
    ocp.solver_options.globalization = 'MERIT_BACKTRACKING'

    ##########                          COST FUNCTION               ##############

    #Converting quaternion to rpy
    rpy_expr = quat_to_RPY(model.x[6:10])

    # ========== Dynamics extraction ========== #
    xdot = model.f_expl_expr  # explicit model

    # Velocity
    v_expr = model.x[3:6]  # v = dot(p)

    # Acceleration (is part of xdot)
    a_expr = xdot[3:6]

    # Jerk = symbolic time derivative of acceleration (d/dt(a)= d/dx(a)*xdot + d/du(a)*u)
    j_expr = ca.jacobian(a_expr, model.x) @ xdot + ca.jacobian(a_expr, model.u) @ model.u

    # Snap = symbolic time derivative of jerk (d/dt(j)= ...)
    s_expr = ca.jacobian(j_expr, model.x) @ xdot + ca.jacobian(j_expr, model.u) @ model.u

    u_hovering = ca.DM([0, 0, m*g0, 0, 0, 0])
    
    # Substitution of u with u_hovering to obtain acc, jerk, snap "at hovering" for last time instant
    a_hover = ca.substitute(a_expr, model.u, u_hovering)
    j_hover = ca.substitute(j_expr, model.u, u_hovering)
    s_hover = ca.substitute(s_expr, model.u, u_hovering)

    # Const function quantities (expressed with respect to state and control)
    y_expr = ca.vertcat(
        model.x[0:6],        # p, v
        rpy_expr,            # RPY
        model.x[10:13],      # omega
        a_expr,              # acceleration
        j_expr,              # jerk
        s_expr,              # snap
        model.u              # control
    )
    
    # Last time instant expression (senza model.u)
    y_expr_e = ca.vertcat(
        model.x[0:6],
        rpy_expr,
        model.x[10:13],
        a_hover,
        j_hover,
        s_hover
    )
    
    # type of cost funtion
    ocp.cost.cost_type = 'NONLINEAR_LS'
    ocp.cost.cost_type_e = 'NONLINEAR_LS'
    # expression to weight in cost function
    ocp.model.cost_y_expr = y_expr
    ocp.model.cost_y_expr_e = y_expr_e
    # Weigths over prediction horizon and last time istant
    ocp.cost.W = W
    ocp.cost.W_e = W_e

    # initialization of cost references for state and input 
    # over prediction horizon and last time istant
    yref = np.zeros(y_expr.numel())
    yref_e = np.zeros(y_expr_e.numel())

    # Riempimento iniziale con primo valore
    yref[0:3] = p_refs[0]
    yref[6:9] = rpy_refs[0]
    yref_e[0:3] = p_refs[-1]
    yref_e[6:9] = rpy_refs[-1]

    ocp.cost.yref = yref
    ocp.cost.yref_e = yref_e

    #solver creation
    ocp_solver = AcadosOcpSolver(ocp)

    # definition of cost references (ocp_solver.yref)
    for i in range(N_horiz):
        x_ref_i = np.concatenate([p_refs[i], np.zeros(3), rpy_refs[i], np.zeros(3)])
        a_ref_i = np.array([0,0,0]) #æcceleration
        j_ref_i = np.array([0,0,0]) #jerk
        s_ref_i = np.array([0,0,0]) #snap
        yref_i = np.concatenate([x_ref_i, a_ref_i, j_ref_i, s_ref_i, np.zeros(nu)])
        ocp_solver.set(i, "yref", yref_i)
    x_ref_final = np.concatenate([p_refs[-1], np.zeros(3), rpy_refs[-1], np.zeros(3),a_ref_i,j_ref_i,s_ref_i])
    ocp_solver.set(N_horiz, "yref", x_ref_final)

    return ocp_solver, N_horiz, nx, nu

def extract_trajectory_from_solver(ocp_solver, model, N_horiz, nx, nu):

    y_expr=model.cost_y_expr

    fun_y = ca.Function('fun_y', [model.x, model.u], [y_expr])
    simX = np.array([ocp_solver.get(i, "x") for i in range(N_horiz + 1)])
    simU = np.array([ocp_solver.get(i, "u") for i in range(N_horiz)])

        # Valuto y_expr per ogni istante (tranne l'ultimo che non ha controllo u)
    y_vals = []
    for i in range(N_horiz):
        y_i = fun_y(simX[i], simU[i])
        y_vals.append(y_i.full().flatten())
    # Per l'ultimo step (senza controllo), uso u=0 (oppure u dell'ultimo step)
    y_last = fun_y(simX[-1], np.zeros(nu))
    y_vals.append(y_last.full().flatten())

    y_vals = np.array(y_vals)  # (N_horiz+1) x dimensione_y_expr

    # Ora estrai gli indici relativi ad accelerazione, jerk, snap all'interno di y_expr
    #               y_expr structure:
    # y_expr = vertcat(
    #    model.x[0:6],        # p(0:6), v(3:6)
    #    rpy_expr,            # RPY  (3)
    #    model.x[10:13],      # omega (3)
    #    a_expr,              # acceleration (3)
    #    j_expr,              # jerk (3)
    #    s_expr,              # snap (3)
    #    model.u              # control (6)
    # )
    # Quindi gli indici sono:
    idx_a_start = 6 + 3 + 3  # p(6) + rpy(3) + omega(3) = 12
    idx_a_end = idx_a_start + 3  # 12-14
    idx_j_start = idx_a_end  # 15
    idx_j_end = idx_j_start + 3  # 18
    idx_s_start = idx_j_end  # 18
    idx_s_end = idx_s_start + 3  # 21

    a = y_vals[:, idx_a_start:idx_a_end]
    j = y_vals[:, idx_j_start:idx_j_end]
    s = y_vals[:, idx_s_start:idx_s_end]

    return simX, simU, a, j, s

def get_state_variables(simX):
    p = simX[:, 0:3]
    v = simX[:, 3:6]
    q = simX[:, 6:10]
    rpy = np.array([quat_to_RPY(qi).T for qi in q])
    rpy=np.squeeze(rpy)
    w = simX[:, 10:13]
    return p, v, rpy, w

def drone_ref_from_obj(p_obj,rpy_obj,radius) :
    # Reference for the drone based on distance from the object
    p_refs = []
    rpy_refs = []
    for poss, rott in zip(p_obj, rpy_obj):
        R_obj = RPY_to_R(*rott)
        offset_dir = R_obj[:, 0]
        p_drone = poss + radius * offset_dir
        p_refs.append(p_drone)
        #vec_to_obj = p_obj - p_drone
        roll = 0
        pitch = 0
        yaw = 0
        rpy_refs.append([float(roll), float(pitch), float(yaw)])
    p_refs = np.squeeze(np.array(p_refs))
    rpy_refs = np.squeeze(np.array(rpy_refs))
    return p_refs, rpy_refs 

#                   MAIN
def main():
    # Time
    t0 = 0.0
    Tf = 10.0
    ts = 0.01

    #drone model setup (both quaternion and rpy)
    model, model_rpy = setup_model()

    #initial conditions for drone
    x0,x0_rpy=setup_initial_conditions()
    R0 = RPY_to_R(x0_rpy[6],x0_rpy[7],x0_rpy[8])
    zb0=R0[:,2] #z axis of body frame, initial orientation
    # Hover thrust
    hover_thrust = m * g0 * zb0
    u_hover = np.concatenate([hover_thrust.full().flatten(), np.zeros(3)])
    
    #OBJECT reference trajectory specification
    p_obj_in = np.array([2, 2, 2])    
    p_obj_f =  np.array([10, 10, 10])
    rot_obj_in =np.array([0,0,0]) 
    rot_obj_f =np.array([0,0,0]) 
    ref_in  = np.concatenate([p_obj_in,rot_obj_in])
    ref_f   = np.concatenate([p_obj_f,rot_obj_f])

    # Reference trajectory (orientation in RPY)
    traj_time, p_obj, rpy_obj = generate_trapezoidal_trajectory(ref_in, ref_f, t0, Tf, ts, v_max=1.0, a_max=1.0)

    #Creation of Drone reference
    radius=2
    p_refs, rpy_refs = drone_ref_from_obj(p_obj,rpy_obj,radius)

    # Cost weights
    W_x = np.diag([10, 10, 10, 1, 1, 1, 10, 10, 10, 1, 1, 1])   #variables in drone model (p,v,rpy,w)
    W_a = np.diag([1, 1, 1])        #accel
    W_j = np.diag([0.1, 0.1, 0.1])        #jerk
    W_s = np.diag([0.1, 0.1, 0.1])        #snap
    W_u = np.diag([1,1,1,1,1,1])    #control
    W_e = ca.diagcat(W_x,W_a,W_j,W_s).full()
    W = ca.diagcat(W_x,W_a,W_j,W_s, W_u).full()

    # configuring and solving OCP
    ocp_solver, N_horiz, nx, nu = configure_ocp(model, x0, p_refs, rpy_refs, Tf, ts, W, W_e,radius)

    status = ocp_solver.solve()
    ocp_solver.print_statistics()
    if status != 0:
        raise RuntimeError(f"Acados solver failed with status {status}")

    # Simulation results extraction (orientation is in quat., since simulation is done in quat.)
    simX, simU, acc, jerk, snap = extract_trajectory_from_solver(ocp_solver, model, N_horiz, nx, nu)
    # Simulation results saving, orientation in RPY
    p, v, rpy, w = get_state_variables(simX)
    x_rpy=np.hstack((p, v, rpy, w))
    #stacking references on states in one matrix
    x_ref_rpy=np.hstack([p_refs, rpy_refs])
    vel_norm    = np.zeros((N_horiz+1,1))
    acc_norm    = np.zeros((N_horiz+1,1))
    jerk_norm   = np.zeros((N_horiz+1,1))
    snap_norm   = np.zeros((N_horiz+1,1))
    err_pos_norm = np.zeros((N_horiz+1,1))

    #get norm of v,a,j,s and of error
    for i in range (N_horiz + 1) :
        vel_norm[i]  = np.linalg.norm(v[i,:])
        acc_norm[i]  = np.linalg.norm(acc[i,:])
        jerk_norm[i] = np.linalg.norm(jerk[i,:])
        snap_norm[i] = np.linalg.norm(snap[i,:])
        err_pos_norm[i]  = np.linalg.norm(x_ref_rpy[i,0:2]-x_rpy[i,0:2])


    # Plot drone states and controls
    #plot_drone(t_sim, 20, simU, x, True, True, model_rpy.t_label, model_rpy.x_labels, model_rpy.u_labels)
    other_labels = [
        rf"||p_d(t)-p(t)||",
        rf"||v(t)||",
        rf"||a(t)||",
        rf"||j(t)||",
        rf"||s(t)||"
        ]

    # Animated Plot
    traj_plot3D_animated(traj_time,p_refs, p_obj, p, labels=['Ref Drone', 'Ref Oggetto', 'Drone'], colors=['blue', 'red','green'])

    #Error norm - plot
    myPlotWithReference(traj_time, np.zeros((err_pos_norm.shape)), err_pos_norm, other_labels[0],"Norm of tracking error", 2)
    #Velocity, acceleration, jerk, snap norms - plot
    myPlot(traj_time,np.hstack([vel_norm, acc_norm, jerk_norm, snap_norm]),other_labels[1:], "Norms of velocity, acceleration, jerk and snap",2)
    #States - plot
    myPlotWithReference(traj_time, x_ref_rpy, x_rpy, model_rpy.x_labels, "States", 2)
    #Control input - plot
    myPlot(traj_time[0:-1], simU, model_rpy.u_labels, "Control laws", 2)
    


if __name__ == "__main__":
    main()